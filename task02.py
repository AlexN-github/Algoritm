# Задание №2
# Написать два алгоритма нахождения i-го по счёту простого числа.
# Функция нахождения простого числа должна принимать на вход натуральное и
# возвращать соответствующее простое число. Проанализировать скорость и
# сложность алгоритмов.

# Вариант №1
# Классический алгоритм Решето Эратосфена

def get_simple_number_erato(n):
    #Функция прокалывает дырки
    def prokalyvaem_dyrki(arr, n): # передаем масив и простое число
        start_search = n**2
        for digit in arr[start_search::n]:
            if digit != 0:  # если он не равен нулю, то
                arr[digit] = 0
        return arr

    lst = []
    arr = []
    arr.append(0); arr.append(0)   # заполняем первый и второй нулями
    while len(lst) != n:
        arr.append(len(arr))
#        for inx,a in enumerate(arr[2:], 2):
#            if arr[inx] != 0:  # если он не равен нулю, то мы нашли простое число и:
#                prokalyvaem_dyrki(arr, a)
        for a in arr[2:]:
            if a != 0:  # если он не равен нулю, то мы нашли простое число и:
                prokalyvaem_dyrki(arr, a)
        lst = [x for x in arr if x != 0]

    return lst[-1]


# Вариант №2
# Поиск простых чисел не используя алгоритм Решето Эротасфена

def get_simple_number(n):
    lst = [2]
    i = 3
    while len(lst) != n:
        for j in lst:
            if j**2-1 > i:
                lst.append(i)
                break
            if (i % j == 0):
                break
        else:
            lst.append(i)
        i +=2
    return lst[-1]

#####################
# Результаты

n = int(input("Введите порядковый номер простого числа:"))

num = get_simple_number_erato(n)
print("Алгоритм Эр. Простое число:", num)

num = get_simple_number(n)
print("Алгоритм не Эр. Простое число:", num)

#####################
# Оцениваем алгоритмы
import timeit
import cProfile

# timeit
s = """
num = get_simple_number_erato(n)
"""
print("Время Эр.:", timeit.timeit(s,number=50,globals=globals()))


s = """
num = get_simple_number(n)
"""
print("Время не Эр.:", timeit.timeit(s,number=50,globals=globals()))


# cProfile
print("Оценка Эратосвена через cProfile")
cProfile.run("get_simple_number_erato(n)")

print("Оценка не Эратосвена через cProfile")
cProfile.run("num = get_simple_number(n)")

# 20ое простое число
# Эр.: 0.06512603000000006
#      851    0.001    0.000    0.001    0.000 task02.py:12(prokalyvaem_dyrki)

# Не Эр.: 0.0037111219999999
#       36    0.000    0.000    0.000    0.000 {built-in method builtins.len}
#       19    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}


# 70ое простое число
# Эр.: 1.23841424
#    13891    0.024    0.000    0.024    0.000 task02.py:12(prokalyvaem_dyrki)

#Не Эр.: 0.024541724999999737
#      175    0.000    0.000    0.000    0.000 {built-in method builtins.len}
#       69    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}


# 120ое простое число
# Эр.: 3.9926523650000005
#    43511    0.074    0.000    0.074    0.000 task02.py:12(prokalyvaem_dyrki)
#Не Эр.: 0.05030167399999996
#      330    0.000    0.000    0.000    0.000 {built-in method builtins.len}
#      119    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}

####################################
####################################
# Выводы
# В алгоритме Эратосфена поиск изначально ведется всех составных (не простых чисел) и потом методом исключения
# этих чисел находим все остальные (т.е. все простые)
# В алгоритме не Эратосфена поиск ведется сразу простых чисел.
# Так же алгоритм Эратосфеена адаптирован под поиск всех  простых чисел в определенной
# последовательности чисел и не адаптирован для ситуации, когда изначально неизвестно какая
# это будет последовательность натуральных чисел и эта последовательность растет. Поэтому алгоритм
# пробегает множенство раз по тем натуральным числам, по которых проверка уже проводилась ранее.
# Алгоритм не Эратосфена не имеет такого недостатка, поэтому показывает значительно лучшие результаты.